üé® Architecture du Projet : Les 3 Design Patterns
Pour rendre cet √©diteur de texte modulaire et facile √† maintenir, j'ai impl√©ment√© trois patrons de conception majeurs. Voici leur r√¥le pr√©cis dans l'application :

1. Le Singleton (Classe Clipboard)
C'est quoi ? Ce pattern garantit qu'une classe n'a qu'une seule et unique instance et fournit un point d'acc√®s global √† celle-ci.

Pourquoi ici ? Le presse-papier est une ressource partag√©e unique. Il serait illogique d'avoir plusieurs presse-papiers diff√©rents actifs en m√™me temps (on ne saurait plus o√π on a copi√© notre texte !).

Dans mon code : Gr√¢ce au constructeur private et √† la m√©thode static getInstance(), peu importe o√π je suis dans l'application, je r√©cup√®re toujours le m√™me objet pour copier/coller.

2. Le Strategy (Interface ExportStrategy)
C'est quoi ? Il permet de d√©finir une famille d'algorithmes, de les encapsuler dans des classes s√©par√©es et de les rendre interchangeables dynamiquement.

Pourquoi ici ? Pour √©viter une longue suite de if (type == WORD) ... else if (type == HTML). Cela respecte le principe Open/Closed : si demain je veux ajouter un format PDF ou Markdown, je cr√©e juste une nouvelle classe sans toucher au code du moteur de l'√©diteur.

Dans mon code : L'√©diteur poss√®de une m√©thode setExportStrategy(). L'utilisateur choisit dans la liste d√©roulante (Word ou HTML), et au moment de cliquer sur "Enregistrer", l'√©diteur d√©l√®gue le travail √† la strat√©gie active sans se soucier de la technique d'√©criture du fichier.

3. L'Observer (Interface StatsObserver)
C'est quoi ? Il d√©finit une d√©pendance "un-√†-plusieurs" : quand un objet change d'√©tat (le Sujet), tous ceux qui l'√©coutent (les Observateurs) sont notifi√©s et mis √† jour automatiquement.

Pourquoi ici ? Pour d√©coupler le moteur de l'interface graphique. Le moteur de texte ne doit pas conna√Ætre l'existence des labels Swing. Il signale juste "J'ai chang√©", et l'interface r√©agit.

Dans mon code : D√®s que je tape une lettre, le TextEditor (Sujet) notifie le WordCounterLabel (Observateur). Cela permet d'avoir le compteur de mots et de caract√®res qui se met √† jour en temps r√©el, de mani√®re fluide.

üöÄ En r√©sum√©
L'utilisation de ces patterns permet d'obtenir un code "Clean" :

Gestion centralis√©e des donn√©es (Singleton).

Flexibilit√© des formats d'enregistrement (Strategy).

R√©activit√© de l'interface utilisateur (Observer).